'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var React = require('react');
var hash = require('./hash');
var parse = require('./parse');
var withTheme = require('./withTheme');
var ThemeProvider = require('./ThemeProvider');

var prefix = 'nano';

var nano = function nano(Component) {
  return function () {
    for (var _len = arguments.length, baseArgs = Array(_len), _key = 0; _key < _len; _key++) {
      baseArgs[_key] = arguments[_key];
    }

    var args = Array.isArray(Component.styles) ? [].concat(_toConsumableArray(Component.styles), baseArgs) : baseArgs;

    var Nano = withTheme(function (_React$Component) {
      _inherits(_class, _React$Component);

      function _class(props) {
        _classCallCheck(this, _class);

        var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, props));

        _this.getStyles = function (_props) {
          var props = Object.assign({}, Component.defaultProps, _props);
          var styles = args.map(function (arg) {
            return typeof arg === 'function' ? arg(props) : arg;
          });
          var className = props.className || prefix + hash(JSON.stringify(styles));
          var css = styles.map(function (style) {
            return parse('.' + className, style);
          }).join('');

          _this.setState({
            className: className,
            css: css
          });
        };

        _this.getBlacklist = function () {
          return [].concat(_toConsumableArray(Object.keys(Nano.propTypes || {})), ['innerRef', 'theme']);
        };

        _this.getProps = function (props) {
          var next = {};
          var blacklist = _this.getBlacklist();
          for (var key in props) {
            if (blacklist.includes(key)) continue;
            next[key] = props[key];
          }

          return next;
        };

        _this.state = {
          className: '',
          css: ''
        };
        return _this;
      }

      _createClass(_class, [{
        key: 'componentWillMount',
        value: function componentWillMount() {
          this.getStyles(this.props);
        }
      }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(next) {
          if (next !== this.props) {
            this.getStyles(next);
          }
        }
      }, {
        key: 'render',
        value: function render() {
          var _state = this.state,
              className = _state.className,
              css = _state.css;

          var next = this.getProps(this.props);

          return [React.createElement(Component, _extends({}, next, {
            ref: this.props.innerRef,
            key: 'Component',
            className: className
          })), !!css && !next.className && React.createElement(Style, { key: 'css', css: css })];
        }
      }]);

      return _class;
    }(React.Component));

    Nano.styles = args;
    Nano.displayName = typeof Component === 'string' ? 'Nano(' + Component + ')' : Component.displayName;

    return Nano;
  };
};

var Style = function Style(_ref) {
  var css = _ref.css;
  return React.createElement('style', { dangerouslySetInnerHTML: { __html: css } });
};

module.exports = nano;
module.exports.ThemeProvider = ThemeProvider;